---
title: "mod_obj class"
author: "Ben Denis Shaffer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mod_obj class}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# `mod_obj` class

In this package we introduce a data structure object called `mod_obj`. Underneath, this is a named R list. The functionality of this package revolves around this `mod_obj` structure, and therefore you will notice that the first, and often only, argument to a function is a `mod_obj`. By design the supplied `mod_obj` is not modified in place, but instead returned. The implication is that you may store the `mod_obj` created for you analysis at every step of analysis, however this is not recommended.


# Initiating a `mod_obj`

To create a `mod_obj` we simply call the `create_mod_obj` function. You can see that this is an empty list, with the additional mob_obj class.
```{r message=FALSE}
library(mmmactive)
mod_obj <- create_mod_obj()
mod_obj
```


# States of the `mob_obj`

As the analysis progresses the states of the `mob_obj` changes with new elements added to the list. These states have a hierarchy, meaning that some steps of an analysis may only we called onto a `mob_obj` after a different one was completed. For example, you may not apply `Transfrom` unless `Load_Data` has been applied.

The following states (and functions to check them) are currently implemented, listed in the order of hierarchy:

* `is.mod_obj`
* `is.activated`
* `is.load_data_ready`
* `is.data_transformed`
* `is.modeled`

```{r}
is.mod_obj(mod_obj)
```

Because we created a `mod_obj` this will evaluate to TRUE.

The rest of the state-checks will be FALSE. In addition to returning FALSE, the checkers try to throw a useful warning message indicating what element is missing for the state to be TRUE.

```{r}
is.activated(mod_obj)
```


```{r}
is.load_data_ready(mod_obj)
```

```{r}
is.data_transformed(mod_obj)
```

```{r}
is.modeled(mod_obj)
```


# `mod_obj` activation

Before beginning the modeling analysis with the `mod_obj`, we must activate the `mod_obj`
Within the MSMP framework we must have two activation input files. 


```{r}
input_file_ModelSetup =  here::here("data","ttn-ModelSetup.csv")
mod_obj <- activate_model_setup(mod_obj, input_file_ModelSetup)
```

We can see that when the following elements have been added to the `mod_obj` we only get a warning that `spec` is missing.

```{r}
names(mod_obj)
is.activated(mod_obj)
```


```{r}
input_file_ModelSpec = here::here("data","ttn-ModelSpec.csv")
mod_obj <- activate_model_spec(mod_obj, input_file_ModelSpec)
```

Finally, when `activate_model_spec` is run, and `spec` is added to the `mod_obj`, `is.activated` is evaluated to TRUE, and the model object is activated. 

```{r}
names(mod_obj)
```

```{r}
is.activated(mod_obj)
```


# `mod_obj` add_group_selector

When the `mod_obj` is activated it may receive the cross-section element `cs`. If this element is present then a group selector is necessary to provide information about which levels of the cross-section should be included. Otherwise data can not be loaded.

```{r}
is.load_data_ready(mod_obj)
```


For example, here we are including 8 regions.

```{r}
rgn <- c("CR", "MAR", "MTN", "MWR", "NER", "NWR", "SER", "WR")
mod_obj <- add_group_selector(mod_obj, vehicles = mod_obj$nmp, regions = rgn)
```

Now we have the `data_group_selector` element which will allow us to go on and load data.

```{r}
mod_obj$data_group_selector
```

```{r}
is.load_data_ready(mod_obj)
```

# Model Spec

Describe the `spec` element

```{r}
mod_obj$spec
```

