---
title: "mod_obj class"
author: "Ben Denis Shaffer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mod_obj class}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

#library(tidyverse)
```


# `mod_obj` class

In this package we introduce a data structure object called `mod_obj`. Underneath, this is a named R list. The functionality of this package revolves around this `mod_obj` structure, and therefore you will notice that the first, and often only, argument to a function is a `mod_obj`. By design the supplied `mod_obj` is not modified in place, but instead returned. The implication is that you may store the `mod_obj` created for you analysis at every step of analysis, however this is not recommended.


# Initiating a `mod_obj`

To create a `mod_obj` we simply call the `create_mod_obj` function. You can see that this is an empty list, with the additional mob_obj class.
```{r}
library(mmmactive)
mod_obj <- create_mod_obj()
mod_obj
```


# States of the `mob_obj`

As the analysis progresses the states of the `mob_obj` changes with new elements added to the list. These states have a hierarchy, meaning that some steps of an analysis may only we called onto a `mob_obj` after a different one was completed. For example, you may not apply `Transfrom` unless `Load_Data` has been applied.

The following states (and functions to check them) are currently implemented, listed in the order of hierarchy:

* `is.mod_obj`
* `is.activated`
* `is.load_data_ready`
* `is.data_transformed`
* `is.modeled`

```{r}
is.mod_obj(mod_obj)
```

Because we created a `mod_obj` this will evaluate to TRUE.

The rest of the state-checks will be FALSE. In addition to returning FALSE, the checkers try to throw a useful warning message indicating what element is missing for the state to be TRUE.

```{r}
is.activated(mod_obj)
```


```{r}
is.load_data_ready(mod_obj)
```

```{r}
is.data_transformed(mod_obj)
```

```{r}
is.modeled(mod_obj)
```


# `mod_obj` activation

Before beginning the modeling analysis with the `mod_obj`, we must activate the `mod_obj`
Within the MSMP framework we must have two activation input files. 

```{r, echo=FALSE}
mod_obj$ModelForm <- ""
mod_obj$Panel <- ""
mod_obj$Time <- ""
mod_obj$BeginDate <- ""
mod_obj$EndDate <- ""
mod_obj$SimStart <- ""
mod_obj$SimEnd <- ""
mod_obj$mroi_step <- ""
mod_obj$cs <- ""
mod_obj$kpi <- ""
```

```{r error=TRUE, eval=FALSE}
mod_obj <- activate_model_setup(mod_obj, 
                                input_file_ModelSetup = "PATH TO YOUR MODEL SETUP .csv FILE")
```

We can see that when the following elements have been added to the `mod_obj` we only get a warning that `spec` is missing.

```{r}
names(mod_obj)
is.activated(mod_obj)
```


```{r, error=TRUE, eval=FALSE}
mod_obj <- activate_model_spec(mod_obj, 
                               input_file_ModelSpec = "PATH TO YOUR MODEL SPEC .csv FILE")
```

```{r, echo=FALSE}
mod_obj$spec<- ""
```

Finally, when `activate_model_spec` is run, and `spec` is added to the `mod_obj`, `is.activated` is evaluated to TRUE, and the model object is activated. 

```{r}
names(mod_obj)
is.activated(mod_obj)
```
